<#

A prettier version of this information is available at: https://john.bruckler.org/Split-vs-Regex-the-fastest-way-cut-open-a-string/

A coworker of mine asked me the other day if I knew the ‘best’ way to get 
an email address out of a string using PowerShell. I was incredibly disinterested 
in the task I was working on, and thought this would be a nice break. Since 
“best” is such a subjective term, it seemed like a good brain teaser.

The string in question was a SIP address. SIP addresses are well-formed strings, 
and so getting to the gooey email center would be a piece of cake no matter how 
you go about it.

There was some other information in the string as well, but it was all delimited 
by semi-colons, so an example string would be:
#>

sip:joe.user@where.i.work.com;some;unnecessary data

<#
In the example string, we’re looking to get joe.user@where.i.work.com out of the 
string. My first thought was to use the split method of the string object to break 
the string into pieces by the semi-colons, then split the first array member on 
the colon. This would put the email address in index position 1 for the given string.
#> 

$string = 'sip:joe.user@where.i.work.com;some;unnecessary data'

# Here we reference the array indices directly using [0] and [1]
$email = $string.split(';')[0].split(':')[1]

<#
Simple and direct.

The other way to go about getting into the guts of a string is through RegEx. There 
are 3 main ‘problems’ with using RegEx. Though, none of them insurmountable. The 
first problem for a lot of people is understanding the pattern. The second problem 
with RegEx is that it’s not always the fastest way to search a string due to the 
overhead of creating objects and some more intensive string splitting than what 
goes on with a split.

The 3rd problem? Well in this case, the 3rd problem is what we’re looking for 
itself: an email address. Matching email addresses with RegEx is a bit like trying 
to hold sand in your hand - you can catch most email addresses with some fairly simple 
RegEx, but capturing all address schemes laid out in RFC 6854 is pretty non-trivial. 

Paul Warren at ex-parrot.com has made this RFC 822 compliant regex available, it’s 82 
lines long and is generated by a Perl module. (RFC 822 was replaced by RFC 6854)

I like the regex at regular-expressions.info, it’s pretty easy to understand, and 
catches most email addresses, with exceptions that the author details on that page.

To match and keep the email address in the SIP address sample using the 
regular-expressions.info regex, I did the following:
#>

$string = 'sip:joe.user@where.i.work.com;some;unnecessary data'
$Pattern = "(\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}\b)"

# Using match populates the $Matches build-in variable with the
# text matched by the expression
$string -match $Pattern
$Matches[0]

<#
So now we have 2 ways of getting the same data from a string. One is dead-simple, 
the other one not much more complicated. But which one is the best?

Well, like I said, ‘best’ is subjective, but in this case, given no other requirements, 
I’ll arbitrarily pick ‘fastest’ to be ‘best’. Thankfully PowerShell has the 
Measure-Command cmdlet which makes this kind of comparison a cakewalk.
#>

$ReSB = {
  $string = 'sip:joe.user@where.i.work.com;some;unnecessary data'
  $Pattern = "(\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}\b)"

  # Using match populates the $Matches build-in variable with the
  # text matched by the expression
  $string -match $Pattern
  $Matches[0]
}

$SpSB = {
  $string = 'sip:joe.user@where.i.work.com;some;unnecessary data'

  # Here we reference the array indices directly using [0] and [1]
  $email = $string.split(';')[0].split(':')[1]
  $email
}

Measure-Command $SpSB

Measure-Command $ReSB

<#
Measure-Command returns how long it takes a command to run, and outputs 
that information in a block, detailing down to the millisecond how long 
 command ran for.

Measure-Command $SpSB
---------------------
Days              : 0
Hours             : 0
Minutes           : 0
Seconds           : 0
Milliseconds      : 0
Ticks             : 2556
TotalDays         : 2.95833333333333E-09
TotalHours        : 7.1E-08
TotalMinutes      : 4.26E-06
TotalSeconds      : 0.0002556
TotalMilliseconds : 0.2556

Measure-Command $ReSB
---------------------
Days              : 0
Hours             : 0
Minutes           : 0
Seconds           : 0
Milliseconds      : 0
Ticks             : 3736
TotalDays         : 4.32407407407407E-09
TotalHours        : 1.03777777777778E-07
TotalMinutes      : 6.22666666666667E-06
TotalSeconds      : 0.0003736
TotalMilliseconds : 0.3736


The first time I ran that code, the regex match took 23 milliseconds - roughly 100x 
slower than the string split method. Running the command multiple times gets an 
average of .25 milliseconds for the split method, and .37 milliseconds for the RegEx method.

The winner at this point is pretty clearly the string split method, which takes on 
average 1/3rd less time to return a result than the RegEx method. This is where the 
“new” (to me) requirement came into play - the code in question will be parsing a 
file line by line, and those lines may or may not contain a SIP address. Since we’re 
only worried about lines that contain addresses, the string split method is out the 
window. After all, -match not only returns true if it matches, it also saves the
 match in a variable for you. Split can’t do that. Right?

Not so fast, not so fast at all! If we capture the output of the split command into a 
variable for every line, then check to make sure that variable is not null, well, then 
we could use split. But what is the performance difference between these methods?

To test, I created a text file with 100 lines of text. 70 lines of lorem ipsum, and 30 
SIP addresses in the format outlined at the beginning of this post. I modified the 
script blocks to loop through the file contents and add any result to an array, then 
ran those through Measure-Command again.

The code:
#>

$log = Get-Content .\email-log.txt

$ReSB = {
  $RECount = @()
  $Pattern = "(\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}\b)"
  foreach ($line in $log)
  {
    if ($line -match $Pattern)
    {
      $RECount += $Matches[1]
    }
  }
  $RECount.Count
}

$SpSB = {
  $SPCount = @()
  foreach ($line in $log)
  {
    $email = $null
    $email = $line.split(';')[0].split(':')[1]
    if ($email -ne $null)
    {
      $SPCount += $email
    }
  }
  $SPCount
}

Measure-Command $SpSB

Measure-Command $ReSB

<#
The results:

Measure-Command $SpSB
---------------------
Days              : 0
Hours             : 0
Minutes           : 0
Seconds           : 0
Milliseconds      : 3
Ticks             : 32106
TotalDays         : 3.71597222222222E-08
TotalHours        : 8.91833333333333E-07
TotalMinutes      : 5.351E-05
TotalSeconds      : 0.0032106
TotalMilliseconds : 3.2106

Measure-Command $ReSB
---------------------
Days              : 0
Hours             : 0
Minutes           : 0
Seconds           : 0
Milliseconds      : 4
Ticks             : 40019
TotalDays         : 4.6318287037037E-08
TotalHours        : 1.11163888888889E-06
TotalMinutes      : 6.66983333333333E-05
TotalSeconds      : 0.0040019
TotalMilliseconds : 4.0019

Looks like using string split is still faster, to the tune of nearly a millisecond. 
I ran the test again with over 5,000 lines of text. It took 262 milliseconds for 
the split method, and 289 milliseconds for the regex method.

The verdict is that you could probably use either one to parse, without too much of 
a performance hit, but the RegEx one, to me, makes more sense when a human is reading 
the code. If there’s a match, do some stuff. We see that construct all the time in code, 
it’s familiar. The split method doesn’t make sense when skimming through code. 
Ultimately it comes down to whether you want fast, or readable.
#>